(. System exit 0)
(def n [nil nil])
n
(nil? n)
(nil? (first n))
(. System exit 0)
(binding [*ns* (or (find-ns 'interpreter.core) (find-ns 'user))] (load-string "(defn is-list-item?
  [item]
  (println \"#### IS-LIST-ITEM? #####\")
  (println item)
  (println (type item))
  (and (= clojure.lang.PersistentArrayMap (type item)) (= (item :type) :list)))"))
(binding [*ns* (or (find-ns 'interpreter.core) (find-ns 'user))] (load-string "(defn is-list-item?
  [item]
  (println \"#### IS-LIST-ITEM? #####\")
  (println item)
  (println (type item))
  (and (= clojure.lang.PersistentArrayMap (type item)) (= (item :type) :list)))"))
(binding [*ns* (or (find-ns 'interpreter.core) (find-ns 'user))] (load-string "(defn is-list-item?
  [item]
  (println \"#### IS-LIST-ITEM? #####\")
  (println item)
  (println (type item))
  (and (= clojure.lang.PersistentArrayMap (type item)) (= (item :type) :list)))"))
(binding [*ns* (or (find-ns 'interpreter.core) (find-ns 'user))] (load-string "(defn is-list-item?
  [item]
  (println \"#### IS-LIST-ITEM? #####\")
  (println item)
  (println (type item))
  (and (= clojure.lang.PersistentArrayMap (type item)) (= (item :type) :list)))"))
(binding [*ns* (or (find-ns 'interpreter.core) (find-ns 'user))] (load-string "(defn is-list-item?
  [item]
  (println \"#### IS-LIST-ITEM? #####\")
  (println item)
  (println (type item))
  (and (= clojure.lang.PersistentArrayMap (type item)) (= (item :type) :list)))"))
(binding [*ns* (or (find-ns 'interpreter.core) (find-ns 'user))] (load-string "(defn insert-into-top
  \"curr-struct is a vector or a map representing a list 
  (format: {:type :list :value [<items in list>]}\"
  [curr-struct tagged-item]
  (println \"**** INSERT_INTO_TOP*****\")
  (println \"curr-struct\")
  (println curr-struct)
  (println \"tagged-item\")
  (println tagged-item)
  (cond 
    (is-vector? curr-struct) 
      (into [] (conj curr-struct tagged-item))
    (is-list-item? curr-struct)
      (do 
        (println \"new-value\")
        (println (concat (curr-struct :value) [tagged-item]))
        (assoc curr-struct :value (concat (curr-struct :value) [tagged-item])))))"))
(binding [*ns* (or (find-ns 'interpreter.core) (find-ns 'user))] (load-string "(defn insert-into-top
  \"curr-struct is a vector or a map representing a list 
  (format: {:type :list :value [<items in list>]}\"
  [curr-struct tagged-item]
  (println \"**** INSERT_INTO_TOP*****\")
  (println \"curr-struct\")
  (println curr-struct)
  (println \"tagged-item\")
  (println tagged-item)
  (cond 
    (is-vector? curr-struct) 
      (into [] (conj curr-struct tagged-item))
    (is-list-item? curr-struct)
      (do 
        (println \"new-value\")
        (println (concat (curr-struct :value) [tagged-item]))
        (assoc curr-struct :value (concat (curr-struct :value) [tagged-item])))))"))
(binding [*ns* (or (find-ns 'interpreter.core) (find-ns 'user))] (load-string "(def operator-map {\"+\" + \"-\" - \"*\" * \"/\" /})
(def bool-map {\"true\" true \"false\" false})
(def builtin-map {
  \"map\" map
  \"filter\" filter
  \"conj\" conj
  \"cons\" cons
  \"first\" first
  \"last\" last
  \"not\" not
  \"rest\" rest})
(defn is-vector?
  [item]
  (= clojure.lang.PersistentVector (type item)))
; (defn vectorify
;   [tokens]
;   (loop [i 0
;    stack []]
;    (println \"BEGINNING\")
;    (println \"STACK\")
;    (println stack)
;    (println \"I = \" i)
;    (if (and (>= i (count tokens))
;     (first stack)
;     (do
;       (let [t (nth tokens i)]
;         (println t)
;         (cond 
;           (= t \"(\") (recur (inc i) (into [] (cons [] stack)))
;             (= t \")\")
;             (do 
;               (let [top-vec (first stack)]
;                 (println \"TOP-VEC \" top-vec)
;                 (let [stack (rest stack)]
;                   (println \"stack = \" stack)
;                   (if (empty? stack)
;                     top-vec
;                     (do
;                       (let [next-vec (first stack)]
;                         (println \"stack before = \" stack)
;                         (println \"NEXT_VEC \" next-vec)
;                         (let [stack (rest stack)]
;                           (println \"stack after  = \" stack)
;                           (recur (inc i) (into [] (cons (conj next-vec top-vec) stack))))))))))
;             :else 
;             (do 
;               (let [curr-vec (first stack)]
;                 (recur (inc i) (assoc stack 0 (into [] (conj curr-vec t))))))))))))
;; (defmulti name dispatch-fn & options)
;; (defmethod multifn dispatch-value & fn-tail)
;; TAGGING
(defn str-literal
  [token]
  (if (and (= (first token) (char 34)) (= (last token) (char 34)))
    token))
(defn num-literal
  [token]
  (try
    (Integer/parseInt token)
    (catch Exception e
      nil)))
  
(defn tag
  [token]
  (let [operator (operator-map token)
        str-literal (str-literal token)
        num-literal (num-literal token)
        bool (bool-map token)
        builtin (builtin-map token)]
  (cond
    (not (nil? operator)) {:type :operator :value operator}
    (not (nil? str-literal)) {:type :literal :value str-literal}
    (not (nil? num-literal)) {:type :literal :value num-literal}
    (not (nil? bool)) {:type :bool :value bool}
    (not (nil? builtin)) {:type :builtin :value builtin}
    :else {:type :identifier :value token})))
;; TOKENIZING
(defn is-list-item?
  [item]
  (println \"#### IS-LIST-ITEM? #####\")
  (println item)
  (println (type item))
  (and (= clojure.lang.PersistentArrayMap (type item)) (= (item :type) :list)))
(defn insert-into-top
  \"curr-struct is a vector or a map representing a list 
  (format: {:type :list :value [<items in list>]}\"
  [curr-struct tagged-item]
  (println \"**** INSERT_INTO_TOP*****\")
  (println \"curr-struct\")
  (println curr-struct)
  (println \"tagged-item\")
  (println tagged-item)
  (cond 
    (is-vector? curr-struct) 
      (into [] (conj curr-struct tagged-item))
    (is-list-item? curr-struct)
      (do 
        (println \"new-value\")
        (println (concat (curr-struct :value) [tagged-item]))
        (assoc curr-struct :value (concat (curr-struct :value) [tagged-item])))))
;; basically implements the built-in \"read-string\" function
;; need to figure out error checking with parentheses
;; not working from the terminal, but works in the REPL
(defn vectorify
  [tokens]
  (loop [i 0
         stack []]
   (println \"STACK\")
   (println stack)
   (if (>= i (count tokens))
     (do 
       (if (= (last tokens) \")\")
        (first stack)
        (do 
          (println \"ERROR\")
          (System/exit -1)))))
    (do (let [t (nth tokens i)]
        (println \"token\")
        (println t)
        (cond 
          (= t \"(\") (recur (inc i) (into [] (cons [] stack)))
          (or (= t \")\") (= t \"]\"))
            (do (let [top-vec (first stack)
                      stack (rest stack)]
                  (if (empty? stack)
                    top-vec
                    (do (let [next-vec (first stack) stack (rest stack)]
                          (recur (inc i) (into [] (cons (conj next-vec top-vec) stack))))))))
          (= t \"[\") (recur (inc i) (into [] (cons {:type \"list\" :value []} stack)))
          :else 
            (do (let [curr-struct (first stack)]
                (recur (inc i) (assoc stack 0 (insert-into-top curr-struct (tag t)))))))))))
;; TODO remove the extra \ from \\s
(defn remove-blanks
  [string]
    (filter (fn[x] (not (empty? x))) (str/split string #\"\\s\")))
;; TODO remove the extra \ from \\[ and \\]
(defn tokenize
  [string]
  (let [spaced-out (remove-blanks (str/replace string #\"[\\[\\]()]\" #(str \" \" % \" \")))]
    spaced-out))
;; EVALUATING
(defn get-type
  [expr]
  (cond 
    (is-vector? expr) :call
    (= :literal (:type expr)) :literal))
(defmulti evaluate get-type)
(defmethod evaluate :call
  [expr]
  (let [function (first expr)]
    (apply (function :value) (map #(evaluate %) (rest expr)))))
(defmethod evaluate :literal
  [expr]
  (:value expr))"))
(binding [*ns* (or (find-ns 'interpreter.core) (find-ns 'user))] (load-string "(def operator-map {\"+\" + \"-\" - \"*\" * \"/\" /})
(def bool-map {\"true\" true \"false\" false})
(def builtin-map {
  \"map\" map
  \"filter\" filter
  \"conj\" conj
  \"cons\" cons
  \"first\" first
  \"last\" last
  \"not\" not
  \"rest\" rest})
(defn is-vector?
  [item]
  (= clojure.lang.PersistentVector (type item)))
; (defn vectorify
;   [tokens]
;   (loop [i 0
;    stack []]
;    (println \"BEGINNING\")
;    (println \"STACK\")
;    (println stack)
;    (println \"I = \" i)
;    (if (and (>= i (count tokens))
;     (first stack)
;     (do
;       (let [t (nth tokens i)]
;         (println t)
;         (cond 
;           (= t \"(\") (recur (inc i) (into [] (cons [] stack)))
;             (= t \")\")
;             (do 
;               (let [top-vec (first stack)]
;                 (println \"TOP-VEC \" top-vec)
;                 (let [stack (rest stack)]
;                   (println \"stack = \" stack)
;                   (if (empty? stack)
;                     top-vec
;                     (do
;                       (let [next-vec (first stack)]
;                         (println \"stack before = \" stack)
;                         (println \"NEXT_VEC \" next-vec)
;                         (let [stack (rest stack)]
;                           (println \"stack after  = \" stack)
;                           (recur (inc i) (into [] (cons (conj next-vec top-vec) stack))))))))))
;             :else 
;             (do 
;               (let [curr-vec (first stack)]
;                 (recur (inc i) (assoc stack 0 (into [] (conj curr-vec t))))))))))))
;; (defmulti name dispatch-fn & options)
;; (defmethod multifn dispatch-value & fn-tail)
;; TAGGING
(defn str-literal
  [token]
  (if (and (= (first token) (char 34)) (= (last token) (char 34)))
    token))
(defn num-literal
  [token]
  (try
    (Integer/parseInt token)
    (catch Exception e
      nil)))
  
(defn tag
  [token]
  (let [operator (operator-map token)
        str-literal (str-literal token)
        num-literal (num-literal token)
        bool (bool-map token)
        builtin (builtin-map token)]
  (cond
    (not (nil? operator)) {:type :operator :value operator}
    (not (nil? str-literal)) {:type :literal :value str-literal}
    (not (nil? num-literal)) {:type :literal :value num-literal}
    (not (nil? bool)) {:type :bool :value bool}
    (not (nil? builtin)) {:type :builtin :value builtin}
    :else {:type :identifier :value token})))
;; TOKENIZING
(defn is-list-item?
  [item]
  (println \"#### IS-LIST-ITEM? #####\")
  (println item)
  (println (type item))
  (and (= clojure.lang.PersistentArrayMap (type item)) (= (item :type) :list)))
(defn insert-into-top
  \"curr-struct is a vector or a map representing a list 
  (format: {:type :list :value [<items in list>]}\"
  [curr-struct tagged-item]
  (println \"**** INSERT_INTO_TOP*****\")
  (println \"curr-struct\")
  (println curr-struct)
  (println \"tagged-item\")
  (println tagged-item)
  (cond 
    (is-vector? curr-struct) 
      (into [] (conj curr-struct tagged-item))
    (is-list-item? curr-struct)
      (do 
        (println \"new-value\")
        (println (concat (curr-struct :value) [tagged-item]))
        (assoc curr-struct :value (concat (curr-struct :value) [tagged-item])))))
;; basically implements the built-in \"read-string\" function
;; need to figure out error checking with parentheses
;; not working from the terminal, but works in the REPL
(defn vectorify
  [tokens]
  (loop [i 0
         stack []]
   (println \"STACK\")
   (println stack)
   (if (>= i (count tokens))
     (do 
       (if (= (last tokens) \")\")
        (first stack)
        (do 
          (println \"ERROR\")
          (System/exit -1)))))
    (do (let [t (nth tokens i)]
        (println \"token\")
        (println t)
        (cond 
          (= t \"(\") (recur (inc i) (into [] (cons [] stack)))
          (or (= t \")\") (= t \"]\"))
            (do (let [top-vec (first stack)
                      stack (rest stack)]
                  (if (empty? stack)
                    top-vec
                    (do (let [next-vec (first stack) stack (rest stack)]
                          (recur (inc i) (into [] (cons (conj next-vec top-vec) stack))))))))
